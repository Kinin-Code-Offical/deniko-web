// This file was generated by Prisma and assumes you have installed the following:
// npm install --save-dev prisma dotenv
import "dotenv/config";
import fs from "node:fs";
import os from "node:os";
import path from "node:path";
import { defineConfig } from "prisma/config";

const ensurePrismaSslFiles = () => {
  const ca = process.env.DATABASE_SSL_CA;
  const cert = process.env.DATABASE_SSL_CERT;
  const key = process.env.DATABASE_SSL_KEY;

  if (!ca && !cert && !key) return;

  const toMultiline = (value?: string) => value?.replace(/\\n/g, "\n");
  const sslDir = path.join(os.tmpdir(), `deniko-prisma-ssl-${process.pid}`);
  fs.mkdirSync(sslDir, { recursive: true });
  const createdPaths: string[] = [];

  const writeIfPresent = (value: string | undefined, filename: string) => {
    if (!value) return undefined;
    const filePath = path.join(sslDir, filename);
    fs.writeFileSync(filePath, toMultiline(value) ?? "", { encoding: "utf8" });
    createdPaths.push(filePath);
    return filePath;
  };

  const cleanup = () => {
    createdPaths.forEach((filePath) => {
      try {
        fs.rmSync(filePath, { force: true });
      } catch {
        /* noop */
      }
    });
    try {
      fs.rmSync(sslDir, { force: true, recursive: true });
    } catch {
      /* noop */
    }
  };

  const registerCleanup = () => {
    if ((registerCleanup as unknown as { registered?: boolean }).registered)
      return;
    (registerCleanup as unknown as { registered?: boolean }).registered = true;
    const signals: NodeJS.Signals[] = ["SIGINT", "SIGTERM", "SIGQUIT"];
    signals.forEach((signal) => {
      process.once(signal, () => {
        cleanup();
        process.exit();
      });
    });
    process.once("exit", cleanup);
  };
  registerCleanup();

  const caPath = writeIfPresent(ca, "ca.pem");
  const certPath = writeIfPresent(cert, "client.pem");
  const keyPath = writeIfPresent(key, "key.pem");

  const forUrl = (filePath: string) => filePath.replace(/\\/g, "/");

  const patchUrl = (raw?: string | null) => {
    if (!raw) return raw ?? undefined;
    try {
      // We use string manipulation instead of URL object to preserve the original password encoding exactly.
      // Some special characters in passwords might be mishandled during URL parsing/re-serialization.
      const url = raw;
      const separator = url.includes("?") ? "&" : "?";

      const params: string[] = [];
      // Force sslmode to 'require' to skip strict hostname/CA verification
      // We append it at the end, which overrides any previous sslmode in the connection string (for libpq)
      params.push("sslmode=require");

      if (certPath) params.push(`sslcert=${forUrl(certPath)}`);
      if (keyPath) params.push(`sslkey=${forUrl(keyPath)}`);

      // On Windows, providing sslrootcert often causes "certificate verify failed" with self-signed certs in CLI
      // On Cloud Run (Linux), we want it for better security if possible.
      if (caPath && process.platform !== "win32") {
        params.push(`sslrootcert=${forUrl(caPath)}`);
      }

      return `${url}${separator}${params.join("&")}`;
    } catch {
      return raw;
    }
  };

  const patchedDatabaseUrl = patchUrl(process.env.DATABASE_URL);
  if (patchedDatabaseUrl) {
    process.env.DATABASE_URL = patchedDatabaseUrl;
  }

  const patchedDirectUrl = patchUrl(process.env.DIRECT_URL);
  if (patchedDirectUrl) {
    process.env.DIRECT_URL = patchedDirectUrl;
  }

  const lastPatchedUrl = patchedDirectUrl ?? patchedDatabaseUrl;
  if (lastPatchedUrl) {
    console.log(`[prisma.config] Final connection URL: ${lastPatchedUrl}`); // ignore-console-check
  }
};

ensurePrismaSslFiles();

const getRequiredEnv = (value: string | undefined, name: string) => {
  if (!value) {
    throw new Error(
      `[prisma.config] Missing required environment variable: ${name}`
    );
  }
  return value;
};

export default defineConfig({
  schema: "prisma/schema.prisma",
  migrations: {
    path: "prisma/migrations",
  },
  datasource: {
    // Pass the patched values directly instead of relying on env() lookup
    url: getRequiredEnv(process.env.DATABASE_URL, "DATABASE_URL"),
  },
});
